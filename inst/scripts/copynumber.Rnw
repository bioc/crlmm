%\VignetteIndexEntry{crlmm copy number Vignette}
%\VignetteDepends{crlmm, genomewidesnp6Crlmm}
%\VignetteKeywords{crlmm, SNP 6}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}

\begin{document}
\title{Estimating copy number for Affymetrix 6.0  with the crlmm Package}
\date{February, 2009}
\author{Rob Scharpf}
\maketitle

<<setup, echo=FALSE, results=hide>>=
options(width=60)
options(continue=" ")
options(prompt="R> ")
@ 

\section{Estimating copy number}

At present, software for copy number estimation is provided only for the
Affymetrix 6.0 platform.  This vignette estimates copy number for the
HapMap samples.  

One may want to explore the devel branch of the \Rpackage{crlmm} package
if interested in copy number estimation. In particular, an improved
interface for users, more error checking, and further development of the
uncertainty estimates for copy number.  Suggested visualizations and
downstream approaches for smoothing the locus-level estimates are
available.  A tech report for the estimation algorithm (available here:
\texttt{http://www.bepress.com/cgi/viewcontent.cgi?article=1193&context=jhubiostat})
is based on version $\geq$ 1.3.10.


\subsection{Preprocess and genotype the samples}

We preprocess and genotype the samples as described in the CRLMM
vignette.

<<requiredPackages>>=
library(crlmm)
library(genomewidesnp6Crlmm)
@ 

Specify the complete path for the CEL files and a directory in which to
store intermediate files:

<<celfiles>>=
celFiles <- list.celfiles("/thumper/ctsa/snpmicroarray/hapmap/raw/affy/1m", full.names=TRUE, pattern=".CEL")[1:10]
outdir <- "/thumper/ctsa/snpmicroarray/rs/data/hapmap/1m/crlmm_release"
@ 

Preprocess and genotype (for more info see the crlmm vignette).

<<genotype>>=
if (!exists("crlmmResult")) {
	if (file.exists(file.path(outdir, "crlmmResult.rda"))){
		load(file.path(outdir, "intensities.rda"))
		load(file.path(outdir, "crlmmResult.rda"))
	}
	else {
		crlmmResult <- crlmm(celFiles, save.it=TRUE, intensityFile=file.path(outdir, "intensities.rda"))
		load(file.path(outdir, "intensities.rda"))
		save(crlmmResult, file=file.path(outdir, "crlmmResult.rda"))
	}
}
@ 

Quantile normalize the nonpolymorphic probes and save the results.

<<cnrma>>=
if(!exists("cnrmaResult")){
	if(file.exists(file.path(outdir, "cnrmaResult.rda"))) load(file.path(outdir, "cnrmaResult.rda"))
	else {
		cnrmaResult <- cnrma(celFiles, cdfName="genomewidesnp6")
		save(cnrmaResult, file=file.path(outdir, "cnrmaResult.rda"))
	}
}
@ 

\subsection{Copy number}

We require 6 items for copy number estimation:

\begin{itemize}
  \item quantile-normalized A intensities (I1 x J)
  \item quantile-normalized B intensities (I1 x J)
  \item quantile-normalized intensities from nonpolymorphic (NP) probes (I2 x J)
  \item genotype calls (I1 x J)
  \item confidence scores of the genotype calls  (I1 x J)
  \item signal to noise ratio (SNR) of the samples (J)
  \end{itemize}
  
  These items are extracted as follows:

<<snpAndCnSummaries>>=
A <- res$A
B <- res$B
genotypes <- crlmm:::calls(crlmmResult)##$calls
conf <- confs(crlmmResult)##$conf
gender <- crlmmResult$gender
SNR <- crlmmResult$SNR
NP <- cnrmaResult$NP
gc()
@ 

A histogram of the signal to noise ratio for the HapMap samples:

<<plotSnr, fig=TRUE>>=
hist(SNR, xlab="SNR", main="")
@ 


<<dates>>=
dts <- celDates(celFiles)
table(format(dts, "%d %b %Y"))
SNRmin <- 5
@ 

We suggest excluding samples with a signal to noise ratio less than
\Sexpr{SNRmin}.  As batch effects can be very large in the
quantile-normalized intensities, we suggest adjusting for date or
chemistry plate.  Ideally, one would have 70+ files in a given
batch. Here we make a table of date versus ancestry:

<<specifyBatch>>=
require(Biobase)
sns <- sampleNames(crlmmResult)
sns[1]
plate <- substr(basename(sns), 13, 13)
table(plate)
table(format(dts, "%d %b %Y"), plate)
@ 

As all of these samples were run on the first week of March, we would
expect that any systematic artifacts to the intensities that develop
over time to be minimal (a best case scenario).  As this is typically
not the case, we illustrate how one may adjust for batch using the
chemistry plate as an argument to the computeCopynumber function.

<<chromosome22>>=
if(!exists("env")){
	CHR <- 22
	if(!file.exists(file.path(outdir, paste("env_chr", CHR, ".rda", sep="")))){
		env <- new.env()
		computeCopynumber(chrom=CHR,
				  A=A,
				  B=B,
				  calls=genotypes,
				  conf=conf,
				  NP=NP,
				  plate=plate,
				  envir=env, 
				  DF.PRIOR=50, 
				  MIN.OBS=1,
				  SNR=SNR,
				  SNRmin=SNRmin)	
		save(env, file=file.path(outdir, paste("env_chr", CHR, ".rda", sep="")))
	} else {
		load(file.path(outdir, paste("env_chr", CHR, ".rda", sep="")))
	}
}
@ 

A class representation would be useful for this sort of data (TODO).
The \Rpackage{oligoSnpSet} class used below is a bit inefficient as the
assay data elements are forced to be the same size.  The advantage is
that all of the assay data is bound to the meta-data.

<<oligoSnpSet>>=
require(oligoClasses)
path <- system.file("extdata", package="genomewidesnp6Crlmm")
load(file.path(path, "snpProbes.rda"))
load(file.path(path, "cnProbes.rda"))
position <- snpProbes[match(env[["snps"]], rownames(snpProbes)), "position"]
position.np <- cnProbes[match(rownames(env[["NP"]]), rownames(cnProbes)), "position"]
CA <- env[["CA"]]
CB <- env[["CB"]]
snpCT <- CA+CB
npCT <- env[["CT"]]
CT <- rbind(snpCT, npCT)
dimnames(CT) <- list(c(env[["snps"]], rownames(env[["NP"]])), env[["sns"]])
genotypes <- matrix(NA, nrow(CT), ncol(CT))
dimnames(genotypes) <- dimnames(CT)
genotypes[1:length(env[["snps"]]), ] <- env[["calls"]]
polymorphic <- c(rep(1, length(env[["snps"]])), rep(0, nrow(npCT)))
fD <- new("AnnotatedDataFrame", 
	  data=data.frame(chromosome=rep(CHR, nrow(CT)), 
	  polymorphic=polymorphic,
	  position=c(position, position.np)),
	  varMetadata=data.frame(labelDescription=c("chromosome",
				 "polymorphic",
				 "position")))
locusSet <- new("oligoSnpSet",
		copyNumber=CT,
		calls=genotypes,
		featureData=fD,
		phenoData=annotatedDataFrameFrom(CT, byrow=FALSE),
		annotation="genomewidesnp6")
@ 

Note that an indicator for the polymorphic probes was created in the
code chunk above.  I use this indicator to smooth the estimates of copy
number from the nonpolymorphic and polymorphic probes separately.  The
uncertainty estimates (work in progress) should reflect that the
nonpolymorphic probes have more variance and the smoothing will take
this into account.  The above algorithm for estimating copy number is
predicated on the assumption that most samples within a batch have copy
number 2 at any given SNP.  For common copy number variants, this
assumption may not hold.  An additional iteration using a bias
correction can improve the estimates.  Set the \Robject{bias.adj}
argument to \Robject{TRUE}.

%The total copy number for all chromosomes can be extracted from a
%\emph{for} loop.  

<<remainingChromosomes, eval=FALSE, echo=FALSE>>=
require(oligoClasses)
if(!exists("env")){
##	for(CHR in c(1:21, 23)){  
	for(CHR in 22){
		cat(CHR, ", ")
		if(!file.exists(file.path(outdir, paste("CT_chr", CHR, ".rda", sep="")))){
			env <- new.env()
			computeCopynumber(chrom=CHR,
					  A=A,
					  B=B,
					  calls=genotypes,
					  conf=conf,
					  NP=NP,
					  plate=plate,
					  envir=env, 
					  DF.PRIOR=50, 
					  MIN.OBS=1,
					  SNR=SNR,
					  SNRmin=5)	
			CA <- env[["CA"]]
			CB <- env[["CB"]]
			snpCT <- CA+CB
			npCT <- env[["CT"]]
			position.snp <- snpProbes[match(env[["snps"]], rownames(snpProbes)), "position"]
			position.np <- cnProbes[match(rownames(env[["NP"]]), rownames(cnProbes)), "position"]
			CT <- rbind(snpCT, npCT)
			dimnames(CT) <- list(c(env[["snps"]], rownames(env[["NP"]])), env[["sns"]])
			genotypes <- matrix(NA, nrow(CT), ncol(CT))
			dimnames(genotypes) <- dimnames(CT)
			genotypes[1:length(env[["snps"]]), ] <- env[["calls"]]
			polymorphic <- c(rep(1, length(env[["snps"]])), rep(0, nrow(npCT)))
			fD <- new("AnnotatedDataFrame", 
				  data=data.frame(chromosome=rep(CHR, nrow(CT)), 
				  polymorphic=polymorphic,
				  position=c(position.snp, position.np)),
				  varMetadata=data.frame(labelDescription=c("chromosome",
							 "polymorphic",
							 "position")))
			pD <- annotatedDataFrameFrom(CT, byrow=FALSE)
			locusSet <- new("oligoSnpSet",
					copyNumber=CT,
					calls=genotypes,
					featureData=fD,
					phenoData=pD,
					annotation="genomewidesnp6")
			save(locusSet, file=file.path(outdir, paste("locusSet_", CHR, ".rda", sep="")))			
		} else {
			load(file.path(outdir, paste("CT_chr", CHR, ".rda", sep="")))
		}
		rm(env); gc()
	}
}
@ 

\section{Suggested plots}

\paragraph{One sample at a time}

Plot physical position versus copy number for the first sample.  Recall
that the copy number estimates were multiplied by 100 and stored as an
integer.

<<oneSample, fig=TRUE, width=8, height=4, include=FALSE>>=
require(ellipse)
par(las=1)
plot(position(locusSet), copyNumber(locusSet)[, 1]/100, pch=".", cex=2, xaxt="n", col="grey70", ylim=c(0,6), 
     ylab="copy number", xlab="physical position (Mb)",
     main=paste(sampleNames(locusSet)[1], ", CHR:", unique(chromosome(locusSet))))
axis(1, at=pretty(range(position(locusSet))), labels=pretty(range(position(locusSet)))/1e6)
I <- fData(locusSet)$polymorphic==0
points(position(locusSet)[I], copyNumber(locusSet)[I, 1]/100, pch=".", col="blue", cex=1)
@ 
<<eval=FALSE>>=
require(SNPchip)
plotCytoband(22, new=FALSE, cytoband.ycoords=c(5.8, 6.0), label.cytoband=FALSE)
@ 

In this example, the estimates of copy number for the nonpolymorphic
probes appear correlated with the polymorphic probes -- a good sign.

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-oneSample}
  \caption{Total copy number (y-axis) for chromosome 22 plotted
    against physical position (x-axis) for one sample.  }
\end{figure}

\paragraph{One SNP at a time}

This section needs to be cleaned up (TODO).  The parameters needed for
drawing prediction regions are plate-specific.

<<intermediateFiles>>=
tau2A <- env[["tau2A"]]
tau2B <- env[["tau2B"]]
sig2A <- env[["sig2A"]]
sig2B <- env[["sig2B"]]
nuA <- env[["nuA"]]
nuB <- env[["nuB"]]
phiA <- env[["phiA"]]
phiB <- env[["phiB"]]
corr <- env[["corr"]]
corrA.BB <- env[["corrA.BB"]]
corrB.AA <- env[["corrB.AA"]]
A <- env[["A"]]
B <- env[["B"]]
@ 

Plot the prediction regions for total copy number 2 and 3 for the first
plate. Plotting symbols are the genotype calls (1=AA, 2=AB, 3=BB); light
grey points are from other plates. One could also add the prediction
regions for 0-4 copies, but it gets crowded.

<<predictionRegion, fig=TRUE, width=8, height=8, include=FALSE>>=
par(las=1, pty="s")
p <- 1 ##indicates plate
J <- grep(unique(plate)[p], plate) ##sample indices for this plate
ylim <- c(6.5,13)
I <- which(phiA > 10 & phiB > 10)  
i <- I[1]
##plate effects are small
log2(phiA[i, ])
log2(phiB[i, ])
plot(log2(A[i, ]), log2(B[i, ]), pch=as.character(genotypes[i, ]), col="grey60", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
points(log2(A[i, J]), log2(B[i, J]), col="black", pch=as.character(genotypes[i, J]))
for(CT in 2){
	if(CT == 2) ellipse.col <- "black" ##else ellipse.col <- "purple"
	for(CA in 0:CT){
		CB <- CT-CA
		A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
		B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
		scale <- c(A.scale, B.scale)
		if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
		if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
		if(CA > 0 & CB > 0) rho <- corr[i, p]		
		lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
			      scale=scale), col=ellipse.col, lwd=2)
	}
}
legend("topright", lwd=3, col="black", legend="2 copies", bty="n")
@ 

\begin{figure}
  \includegraphics[width=0.9\textwidth]{copynumber-predictionRegion}
  \caption{Prediction regions for copy number 2 for one SNP.  The
    plate effects are negligible for this SNP and we only plot the
    prediction region for the first plate.}
\end{figure}


<<predictionRegion, eval=FALSE, echo=FALSE>>=
par(las=1, pty="s", ask=TRUE)
p <- 1 ##indicates plate
J <- grep(unique(plate)[p], plate) ##sample indices for this plate
ylim <- c(6.5,13)
I <- which(phiA > 10 & phiB > 10)
col <- c("grey0", "grey30", "grey70")
cex <- 3
for(j in seq(along=I)){
	i <- I[j]
	J1 <- grep("C", plate) ##sample indices for this plate
	J2 <- grep("Y", plate) ##sample indices for this plate	
	J3 <- grep("A", plate)
	plot(log2(A[i, ]), log2(B[i, ]), pch=21, col="grey60", type="n", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
	points(log2(A[i, J1]), log2(B[i, J1]), col=col[1], pch=".", cex=cex)
	points(log2(A[i, J2]), log2(B[i, J2]), col=col[2], pch=".", cex=cex)
	points(log2(A[i, J3]), log2(B[i, J3]), col=col[3], pch=".", cex=cex)
	P <- 1:3
	ellipse.col <- col
	for(p in seq(along=P)){
		for(CT in 2){
			for(CA in 0:CT){
				CB <- CT-CA
				A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
				B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
				scale <- c(A.scale, B.scale)
				if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
				if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
				if(CA > 0 & CB > 0) rho <- corr[i, p]		
				lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
					      scale=scale), col=ellipse.col[p], lwd=2)
			}
		}

	}
	legend("topright", lwd=3, col=ellipse.col, legend=unique(plate), bty="n")	
}
@ 

Look at the distribution of shifts in the predicted centers across the
plates.  The biggest shifts are for SNPs that have no observations in a
subset of the plates -- need more shrinkage here.

<<shifts, eval=FALSE, echo=FALSE>>=
shiftA <- log2(nuA+phiA)
d <- suppressWarnings(apply(shiftA, 1, function(x) diff(range(x, na.rm=TRUE))))
hist(d)
index <- which(d > 1.5)
plate1 <- plate2 <- rep(NA, length(index))
for(i in seq(along=index)){
	plate1[i] <- which(shiftA[index[i], ] == maxA[index[i]])
	plate2[i] <- which(shiftA[index[i], ] == minA[index[i]])
}
par(ask=TRUE)
par(las=1)
for(j in seq(along=index)){
	i <- index[j]
	J1 <- grep(plate[plate1[j]], plate) ##sample indices for this plate
	J2 <- grep(plate[plate2[j]], plate) ##sample indices for this plate
	ylim <- c(6.5,13)
	plot(log2(A[i, ]), log2(B[i, ]), pch=as.character(genotypes[i, ]), col="grey60", cex=0.9, ylim=ylim, xlim=ylim, xlab="A", ylab="B")
	points(log2(A[i, J1]), log2(B[i, J1]), col="brown", pch=as.character(genotypes[i, J1]))
	points(log2(A[i, J2]), log2(B[i, J2]), col="blue", pch=as.character(genotypes[i, J2]))
	CT <- 2
	P <- c(plate1[j], plate2[j])
	for(p in seq(along=P)){
		if(p == 1) ellipse.col="brown" else ellipse.col="blue"
		for(CA in 0:CT){
			CB <- CT-CA
			A.scale <- sqrt(tau2A[i, p]*(CA==0) + sig2A[i, p]*(CA > 0))
			B.scale <- sqrt(tau2B[i, p]*(CB==0) + sig2B[i, p]*(CB > 0))
			scale <- c(A.scale, B.scale)
			if(CA == 0 & CB > 0) rho <- corrA.BB[i, p]
			if(CA > 0 & CB == 0) rho <- corrB.AA[i, p]
			if(CA > 0 & CB > 0) rho <- corr[i, p]			
			lines(ellipse(x=rho, centre=c(log2(nuA[i, p]+CA*phiA[i, p]), log2(nuB[i, p]+CB*phiB[i, p])),
				      scale=scale), col=ellipse.col, lwd=2)
		}
	}
}
legend("topright", lwd=3, col=c("brown", "blue"), legend=c("2 copies, plate 1", "2 copies, plate 2 "), bty="n")
@ 

Now look at shifts for which we have at least 3 observations in each
genotype cluster (TO DO).

<<shifts, eval=FALSE, echo=FALSE>>=
shiftA <- log2(nuA+phiA)
maxA <- apply(shiftA, 1, max, na.rm=TRUE)
minA <- apply(shiftA, 1, min, na.rm=TRUE)
d <- maxA - minA
hist(d)
index <- which(d > 0.2)
plate1 <- plate2 <- rep(NA, length(index))
for(i in seq(along=index)){
	plate1[i] <- which(shiftA[index[i], ] == maxA[index[i]])
	plate2[i] <- which(shiftA[index[i], ] == minA[index[i]])
}
@ 


\section{Session information}
<<>>=
sessionInfo()
@ 


\end{document}
