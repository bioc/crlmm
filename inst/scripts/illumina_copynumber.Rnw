%\VignetteIndexEntry{crlmm copy number Vignette for Illumina}
%\VignetteDepends{crlmm}
%\VignetteKeywords{crlmm, illumina}
%\VignettePackage{crlmm}
\documentclass{article}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage[margin=1in]{geometry}
\newcommand{\crlmm}{\Rpackage{crlmm}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}
\newcommand{\R}{\textsf{R}}

\begin{document}
\title{Using \crlmm{} for copy number estimation and genotype calling
  with Illumina platforms} 

\date{\today} 

\author{Rob Scharpf}
\maketitle

Allele-specific copy number estimation in the crlmm package is
available for several Illumina platforms.  As described in the
\texttt{copynumber} vignette, copy number estimation in \crlmm{} works
best when there are a sufficient number of samples such that AA, AB,
and BB genotypes are observed at most loci. For small studies (e.g.,
fewer than 50 samples), there will be a large number of SNPs that are
monomorphic. For monomorphic SNPs, the estimation problem becomes more
difficult and alternative strategies that estimate the relative total
copy number may be preferable.  In addition to installing \crlmm{},
one must also install the appropriate annotation package for the
Illumina platform.  In the following code, we list the platforms for
which annotation packages are currently available. Next we create a
directory where output files will be stored and indicate the directory
that contains the IDAT files that will be used in our analysis.

<<setup, echo=FALSE, results=hide>>=
options(width=70)
options(continue=" ")
@ 

<<libraries>>=
library(crlmm)
crlmm:::validCdfNames()
outdir <- "/thumper/ctsa/snpmicroarray/rs/data/hapmap/crlmmVignette/release/illumina"
dir.create(outdir, showWarnings=FALSE, recursive=TRUE)
datadir <- "/thumper/ctsa/snpmicroarray/illumina/IDATS/370k"
@ 

To perform copy number analysis on the Illumina platform, several
steps are required.  The first step is to read in the IDAT files and
create a container for storing the red and green intensities. These
intensities are quantile normalized in the function
\Rfunction{crlmmIllumina}, and then genotyped using the crlmm
algorithm.  Details on the crlmm genotyping algorithm are described
elsewhere.  It is important to specify \Robject{save.it = TRUE} and
provide output files to store the quantile normalized intensities. We
will make use of the normalized intensities when we estimate copy
number.  The object returned by \Rfunction{crlmmIllumina} in an
instance of the \Robject{SnpSet} class, a container for storing the
genotype calls and the genotype confidence scores.  The genotype
confidence scores are saved as an integer, and can be converted back
to a $[0, 1]$ probability scale by the transformation
$round(-1000*log2(1-p))$.  At this point, one may want to extract the
scan date of the arrays for later use.  The scan dates can be pulled
from the RG object and added to the \Robject{SnpSet} returned by
\Rfunction{crlmmIllumina} as illustrated below.

%\texttt{copynumber.pdf} vignette, we provide an option to preprocess
%and genotype using ordinary matrices (large RAM, but quicker access)
%or \Robject{ff} objects (low RAM, but more I/O overhead). In the
%analysis below, the sample size is small (n=43) and we use matrices.
%(Users wanting the \Rpackage{ff} implementation should try
%\Rfunction{crlmm:::crlmmIllumina2} with the same arguments.)

<<samplesToProcess>>=
samplesheet = read.csv(file.path(datadir, "HumanHap370Duo_Sample_Map.csv"), header=TRUE, as.is=TRUE)
samplesheet <- samplesheet[-c(28:46,61:75,78:79), ]
arrayNames <- file.path(datadir, unique(samplesheet[, "SentrixPosition"]))
grnfiles = all(file.exists(paste(arrayNames, "_Grn.idat", sep="")))
redfiles = all(file.exists(paste(arrayNames, "_Red.idat", sep="")))
@ 

<<samplesToProcess2, echo=FALSE>>=
if(!exists("crlmmResult")){
	if(!file.exists(file.path(outdir, "crlmmResult.rda"))){
		RG <- readIdatFiles(samplesheet, 
				    path=dirname(arrayNames[1]), 
				    arrayInfoColNames=list(barcode=NULL, position="SentrixPosition"), 
				    saveDate=TRUE)
		crlmmResult <- crlmmIllumina(RG=RG, 
					     cdfName="human370v1c", 
					     sns=pData(RG)$ID, 
					     returnParams=TRUE,
					     cnFile=file.path(outdir, "cnFile.rda"),
					     snpFile=file.path(outdir, "snpFile.rda"),
					     save.it=TRUE)
		protocolData(crlmmResult)$ScanDate <- protocolData(RG)$ScanDate
		range(protocolData(crlmmResult)$ScanDate)
		save(crlmmResult, file=file.path(outdir, "crlmmResult.rda"))
		rm(RG); gc()
	} 
}
@ 

<<samplesToProcess3, eval=FALSE>>=
RG <- readIdatFiles(samplesheet, 
		    path=dirname(arrayNames[1]), 
		    arrayInfoColNames=list(barcode=NULL, position="SentrixPosition"), 
		    saveDate=TRUE)
crlmmResult <- crlmmIllumina(RG=RG, 
			     cdfName="human370v1c", 
			     sns=pData(RG)$ID, 
			     returnParams=TRUE,
			     cnFile=file.path(outdir, "cnFile.rda"),
			     snpFile=file.path(outdir, "snpFile.rda"),
			     save.it=TRUE)
protocolData(crlmmResult)$ScanDate <- protocolData(RG)$ScanDate
range(protocolData(crlmmResult)$ScanDate)
rm(RG); gc()
@ 

\noindent Finally, we load a few of the intermediate files that were
created during the preprocessing and genotyping.
<<loadIntermediate, eval=FALSE>>=
load(file.path(outdir, "snpFile.rda"))
res <- get("res")
load(file.path(outdir, "cnFile.rda"))
cnAB <- get("cnAB")
load(file.path(outdir, "crlmmResult.rda"))
@ 

<<loadIntermediate, eval=TRUE, echo=FALSE>>=
if(!exists("res")){
	load(file.path(outdir, "snpFile.rda"))
	res <- get("res")
	load(file.path(outdir, "cnFile.rda"))
	cnAB <- get("cnAB")
	load(file.path(outdir, "crlmmResult.rda"))
}
@ 

After running the crlmm algorithm, we construct a container for
storing the quantile normalized intensities, genotype calls, and
allele-specific copy number estimates.  A few helper functions for
facilitating the construction of this container have been added to the
inst/scripts directory of this package and can be sourced as follows.
Documentation for these helper functions will be available in the
devel version of this package.

<<constructContainer, eval=FALSE>>=
path <- system.file("scripts", package="crlmm")
source(file.path(path, "helperFunctions.R"))
fD <- constructFeatureData(c(res$gns, cnAB$gns), cdfName="human370v1c")
new.order <- order(fD$chromosome, fD$position)
fD <- fD[new.order, ]
aD <- constructAssayData(cnAB, res, crlmmResult, order.index=new.order)
protocolData(crlmmResult)$batch <- vector("integer", ncol(crlmmResult))
container <- new("CNSetLM", 
		 assayData=aD,
		 phenoData=phenoData(crlmmResult),
		 protocolData=protocolData(crlmmResult),
		 featureData=fD,
		 annotation="human370v1c")
@ 

<<container2,echo=FALSE>>=
if(!file.exists(file.path(outdir, "cnSet"))){
	path <- system.file("scripts", package="crlmm")
	source(file.path(path, "helperFunctions.R"))
	fD <- constructFeatureData(c(res$gns, cnAB$gns), cdfName="human370v1c")
	new.order <- order(fD$chromosome, fD$position)
	fD <- fD[new.order, ]
	aD <- constructAssayData(cnAB, res, crlmmResult, order.index=new.order)
	protocolData(crlmmResult)$batch <- vector("integer", ncol(crlmmResult))
	container <- new("CNSetLM", 
			 assayData=aD,
			 phenoData=phenoData(crlmmResult),
			 protocolData=protocolData(crlmmResult),
			 featureData=fD,
			 annotation="human370v1c")
}
@ 



As described in the \texttt{copynumber} vignette, two \R{} functions
for copy number estimation are available: \Rfunction{crlmmCopynumber}
and \Rfunction{crlmmCopynumber2}.  The latter requires that the assay
data elements are represented using \Robject{ff} objects.  As the
dataset for this vignette is small (43 arrays) and the above steps did
not make use of the \Robject{ff} features, constructing \Robject{ff}
objects at this point in the analysis would serve little purpose.  The
decision to use ordinary matrices or \Robject{ff} objects should be
decided at the beginning of the analysis and then propogated to both
the genotyping and copy number estimation steps.  Here, we use the
\Rfunction{crlmmCopynumber} to estimate copy number.

<<estimateCopynumber, echo=FALSE>>=
if(!exists("cnSet")){
	if(!file.exists(file.path(outdir, "cnSet.rda"))){
		cnSet <- crlmmCopynumber(container, verbose=FALSE)
		save(cnSet, file=file.path(outdir, "cnSet.rda"))
	} else load(file.path(outdir, "cnSet.rda"))
}
@ 

<<estimateCopynumber, eval=FALSE>>=
cnSet <- crlmmCopynumber(container, verbose=TRUE)
@ 

%In the following code, we define helper functions to construct a
%\Robject{featureData} object that chromosome and physical position
%annotation for each marker. We then define a constructor for
%initializing the assay data -- the copy number estimation algorithm
%requires normalized intensities, genotype calls, and genotype
%confidence scores.  Note that the order of the construction is
%important.  In particular, the validity method for the
%\Robject{CNSetLM} object requires a 'batch' label in the
%\Robject{protocolData} slot and that 'chromosome', 'position', and
%'isSnp' labels are present in the \Robject{featureData} slot.  With
%the object \Robject{cnSet} in hand, one can proceed with the copy
%number analysis as outlined in the \texttt{copynumber.pdf} vignette.
%Useful accessors and visualizations of the locus-level estimates are
%also discussed in the \texttt{copynumber.pdf} vignette.


\paragraph{Accessors for extracting the locus-level copy number
  estimates.}

As an example of how to use accessors to obtain the allele-specific CN
estimates, the following code chunk extracts the allele-specific copy
number for polymorphic markers on chromosome 21.

<<acn-accessor>>=
marker.index <- which(chromosome(cnSet) == 21 & isSnp(cnSet))
ca <- CA(cnSet)[marker.index, ]/100
cb <- CB(cnSet)[marker.index, ]/100
missing.index <- which(rowSums(is.na(ca))==ncol(cnSet))
ca <- ca[-missing.index, ]
cb <- cb[-missing.index, ]
@ 
\noindent Negating the \Robject{isSnp} function could be used to
extract the estimates at nonpolymorphic markers. For instance,
<<monomorphic-accessor>>=
cn.monomorphic <- CA(cnSet)[which(chromosome(cnSet) == 21 & !isSnp(cnSet)), ]/100
@ 

At polymorphic loci, the total copy number is the sum of the number of
copies of the A allele and the number of copies for the B allele.  At
nonpolymorphic loci, the total copy number is the number of copies for
the A allele.  The helper function totalCopyNumber can be used to
extract the total copy number for all polymorphic and nonpolymorphic
markers.  Documentation of the \Rfunction{totalCopyNumber} will be
available in the devel version of the \Rpackage{oligoClasses}.

<<copyNumberHelper>>=
cn.total <- ca+cb
cn.total2 <- totalCopyNumber(cnSet, i=marker.index)
cn.total2 <- cn.total2[-missing.index, ]
dimnames(cn.total) <- NULL
all.equal(cn.total2, cn.total)
@ 

A few simple visualizations may be helpful at this point. The first
plot is a histogram of the signal to noise ratio of the sample -- an
overall measure of how well the genotype clusters separate.  (This
statistic tends to be much higher for Illumina than for the Affymetrix
platforms.) The second is a visualization of the total copy number
estimates plotted versus physical position on chromosome 1 for the two
samples with the lowest (top) and highest (bottom) signal to noise
ratios.  

<<snr, fig=TRUE>>=
hist(cnSet$SNR, breaks=15)
@ 

<<firstSample, fig=TRUE>>=
low.snr <- which(cnSet$SNR == min(cnSet$SNR))
high.snr <- which(cnSet$SNR == max(cnSet$SNR))
x <- position(cnSet)[marker.index]
x <- x[-missing.index]
par(mfrow=c(2,1), las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 1, 1,1))
for(j in c(low.snr, high.snr)){
	cn <- cn.total[, j]
	cn[cn < 0.05] <- 0.05
	plot(x,
	     cn,
	     pch=".", ylab="copy number", xaxt="n", ylim=c(0, 6))
}
axis(1, at=pretty(x), labels=pretty(x/1e6))
mtext("Mb", 1, outer=TRUE, line=2)
@ 

Here's a very simple approach to handle outliers by applying a running
median using a window of size 3.  Following outlier removal, we
suggest applying a wave correction to adjust for more global waves
followed by a segmentation or hidden markov model.

<<removeOutliers, fig=TRUE>>=
par(mfrow=c(2,1), las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 1, 1,1))
for(j in c(low.snr, high.snr)){
	cn <- cn.total[, j]
	x <- x[!is.na(cn)]
	cn <- cn[!is.na(cn)]
	y <- as.numeric(runmed(cn, k=3))
	plot(x,
	     y,
	     pch=".", ylab="copy number", xaxt="n", log="y", ylim=c(0.5,5))
	legend("topright", bty="n", legend=paste("SNR =", round(cnSet$SNR[j], 1)))
	abline(h=2, col="grey70")
}
axis(1, at=pretty(x), labels=pretty(x/1e6))
mtext("Mb", 1, outer=TRUE, line=2)
@ 

%Next we remove some of the waves using \Rpackage{limma}'s function
%\Rfunction{loessFit}.
%<<wavecorrection, fig=TRUE>>=
%require(limma)
%par(mfrow=c(2,2), las=1, mar=c(0.5, 4, 0.5, 0.5), oma=c(4, 1, 1,1))
%for(j in c(low.snr, high.snr)){
%	y <- copyNumber(cnSet)[chromosome(cnSet) == 1, j]/100
%	missing <- is.na(y)
%	x <- x[!missing]
%	y <- y[!missing]
%	dist <- diff(x)
%	index <- c(0, cumsum(log10(dist) > 6))
%	x.split <- split(x, index)
%	y <- as.numeric(runmed(y, k=3))
%	y.split <- split(y, index)
%	y.smooth <- vector("list", length(y.split))
%	for(i in seq_along(y.smooth)){
%		fit <- loessFit(y=y.split[[i]], x= x.split[[i]], span=0.3)
%		y.smooth[[i]] <- 2+fit$residuals 
%	}
%	plot(unlist(x.split),
%	     unlist(y.split),
%	     pch=".", ylab="copy number", xaxt="n", log="y", ylim=c(0.5,5))
%	plot(unlist(x.split),
%	     unlist(y.smooth),
%	     pch=".", ylab="copy number", xaxt="n", log="y", ylim=c(0.5,5), yaxt="n")
%	legend("topright", bty="n", legend=paste("SNR =", round(cnSet$SNR[j], 1)))
%	abline(h=2, col="grey70")	
%	if(j == high.snr){
%		axis(1, at=pretty(x), labels=pretty(x/1e6))
%		mtext("Mb", 1, outer=TRUE, line=2)
%	}
%}
%@ 
\section{Session information}
<<sessionInfo, results=tex>>=
toLatex(sessionInfo())
@ 


\end{document}



